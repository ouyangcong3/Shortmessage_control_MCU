C51 COMPILER V9.54   GSM3                                                                  11/22/2015 19:51:27 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE GSM3
OBJECT MODULE PLACED IN GSM3.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE GSM3.C OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include<reg52.h>
   2          #include<intrins.h>
   3          #define uchar unsigned char
   4          #define uint unsigned int
   5          #define RxIn 110  //定义接收的数组长度为90
   6          uchar code AT[]="AT"; //握手信号
   7          uchar code ATE[]="ATE";  //关回显
   8          uchar code AT_CNMI[]="AT+CNMI=2,1";//设置这组参数来了新信息直接显示到串口，不作存储
   9                                  //部分模块需设置成AT+CNMI=2,2，建议模块跟PC测试后再编程
  10          
  11          uchar code AT_CSCA[]="AT+CSCA=\"+8613010710500\"";//设置服务中心号码
  12          uchar code AT_CMGF[]="AT+CMGF=1";//设置短信的格式为text格式
  13          uchar code AT_CMGR[]="AT+CMGR=";//读取短信指令
  14          uchar code AT_CMGS[]="AT+CMGS=";//发送短信指令
  15          uchar code AT_CMGD[]="AT+CMGD=";//删除保存的短信
  16          uchar code successfully[]="Operate Successfully!";//发送操作成功信息到目标号码
  17          uchar code fail[]="Operate failed,try again!";  //发送操作失败信息到目标号码
  18          uchar AT_delete[12];
  19          uchar AT_Read[12];  //用来存储发送读取短信指令 
  20          uchar AT_SendNumber[25];  //用来存储发送短信号码指令
  21          uchar numberbuf[3];    //用来保存短信条数 
  22          uchar idata SystemBuf[RxIn];  //储存出口接收数据 
  23          uchar CommandBuf[6];   //用来储存指令 
  24          uchar idata state[17];    //用来存储IO口状态 
  25          uchar idata state1[17];  //用来存储IO口状态 
  26          uchar Rx=0;
  27          uint temp;  //记录状态   
  28          uchar temp1;  // 用于记录P0口状态
  29          uchar temp2;   //用于记录P2口状态 
  30          bit check=0;  //查询标志位 
  31          bit receiveready=0; //接收短信标志位
  32          bit sendready=0;//发送短信准备标志位
  33          bit send=0;   //发送短信标志位
  34          bit flag=0; //指令标志位
  35          sbit P3_7=P3^7;//启动GSM的启动线连IGT
  36          
  37          sbit realy0=P1^4;//继电器1
  38          sbit realy1=P2^6;//继电器2
  39          
  40          sbit test4=P1^3;//测试点4
  41          sbit test5=P1^5;//继电器2
  42          
  43          sbit L1=P1^6;
  44          sbit L2=P1^7;
  45          
  46          sbit realy2=P2^3;//继电器2
  47          sbit realy3=P0^3;//继电器4
  48          sbit realy4=P0^4;  //继电器5
  49          sbit realy5=P0^5;  //继电器6
  50          sbit realy6=P0^6;  //继电器7
  51          sbit realy7=P0^7;//继电器8
  52          
  53          sbit key1=P3^4; //开关1
  54          sbit key2=P3^5; //开关2
  55          sbit key3=P3^4; //开关3
C51 COMPILER V9.54   GSM3                                                                  11/22/2015 19:51:27 PAGE 2   

  56          sbit key4=P2^3; //开关4
  57          sbit key5=P2^4; //开关5
  58          sbit key6=P2^5; //开关6
  59          sbit key7=P2^6; //开关7
  60          sbit key8=P2^7; //开关8
  61          void Delay_ms(uint i);
  62          void Start_GSM(void);
  63          void UART_init (void);
  64          void sendchar(uchar ch);
  65          void sendstring(uchar *p);
  66          void GSM_INIT(void);
  67          void receive_ready(void);
  68          void message_read(void);
  69          void read_message(void);
  70          void sendmessage(void);
  71          /*********************************************************************************************************
             -*********/
  72          ///////////////////函数void Delay_ms(uint i);实现功能:进行毫秒延时///////////////////////////////////
  73          /*********************************************************************************************************
             -*********/
  74          void Delay_ms(uint i)
  75          {
  76   1          unsigned int j;
  77   1          for(;i>0;i--){
  78   2          for(j=0;j<125;j++)
  79   2          {;}
  80   2      }
  81   1      }
  82          /*********************************************************************************************************
             -*********/
  83          ////////////函数void Start_GSM(void);实现功能:对TC35进行启动,开启TC35///////////////////////////////////
  84          //功能详述:单片机上的P3_7管脚是跟TC35的IGT管脚相连;需要启动TC35,必须在 
  85          //15脚(/IGT)加时长至少为100ms的低电平信号,
  86          ///且该信号下降沿时间小于1ms。启动后，15 脚的信号应保持高电平.
  87          /*********************************************************************************************************
             -*********/
  88          void Start_GSM(void)
  89          {
  90   1        P3_7=0;
  91   1        Delay_ms(1000);
  92   1        P3_7=1;
  93   1        Delay_ms(1000);
  94   1      }
  95          /********函数void UART_init;实现功能:对串口进行初始化////////////////////////////////////////////////
  96          /*********************************************************************************************************
             -*********/
  97          void UART_init (void)
  98          {
  99   1          SCON = 0x50 ;  //SCON: serail mode 1, 8-bit UART, enable ucvr   
 100   1                               //UART为模式1，8位数据，允许接收
 101   1                TMOD |= 0x21 ; //TMOD: timer 1, mode 2, 8-bit reload             
 102   1                               //定时器1为模式2,8位自动重装
 103   1                PCON |= 0x00 ; //SMOD=1; 
 104   1                TH1 = 0xFD ;   //Baud:9600 fosc="11".0592MHz 
 105   1                IE |= 0x90 ;     //Enable Serial Interrupt 
 106   1                TR1 = 1 ;       // timer 1 run 
 107   1                TI=1;  
 108   1         
 109   1        }
 110          /*********************************************************************************************************
             -*********/
 111          ////////////函数void sendchar(uchar ch);实现功能:发送一字节数据///////////////////////////////////////////
C51 COMPILER V9.54   GSM3                                                                  11/22/2015 19:51:27 PAGE 3   

             -/////
 112          /*********************************************************************************************************
             -*********/
 113          void sendchar(uchar ch)
 114          {
 115   1        SBUF=ch;
 116   1        while(TI==0);
 117   1        TI=0;
 118   1      }
 119          /*********************************************************************************************************
             -*********/
 120          ///////////函数void sendstring(uchar *p);实现功能:通过串口发送字符串/////////////////////////////////////
 121          /*********************************************************************************************************
             -*********/
 122          void sendstring(uchar *p)
 123          {
 124   1        while(*p)
 125   1        {
 126   2          sendchar(*p);
 127   2          p++;
 128   2        }
 129   1        sendchar(0x0D);//回车
 130   1        sendchar(0x0A); //换行
 131   1      }
 132          /*********************************************************************************************************
             -*********/
 133          ///////////////////函数void receive(void) interrupt 4 using 1;实现功能:通过串口接收数据///////////////////
             -////////////
 134          /*********************************************************************************************************
             -*********/
 135          void receive(void) interrupt 4 using 1
 136          {   
 137   1        if(RI)
 138   1        {
 139   2            if(Rx<RxIn) //RxIn接收数组长度
 140   2            {
 141   3              SystemBuf[Rx]=SBUF; //储存出口接收数据
 142   3              Rx++;
 143   3            }
 144   2            RI=0;
 145   2          }
 146   1      }
 147          /*********************************************************************************************************
             -*********/
 148          ///////////////////函数void GSM_INIT(void);实现功能:初始化TC35模块///////////////////////////////
 149          /*********************************************************************************************************
             -*********/
 150          void GSM_INIT(void)
 151          { 
 152   1      LOOP:
 153   1        Delay_ms(1000);
 154   1        sendstring(AT);
 155   1        Delay_ms(1000);
 156   1          sendstring(ATE);
 157   1        Delay_ms(1000);
 158   1        sendstring(AT_CNMI); //AT_CNMI[]="AT+CNMI=2,1";设置这组参数来了新信息直接显示到串口，
 159   1                //不作存储 部分模块需设置成AT+CNMI=2,2，建议模块跟PC测试后再编程
 160   1        Delay_ms(1000);
 161   1        sendstring(AT_CSCA);//设置服务中心号码
 162   1        Delay_ms(1000);
 163   1        for(Rx=0;Rx<RxIn;Rx++)//RxIn接收数组长度
 164   1          {
C51 COMPILER V9.54   GSM3                                                                  11/22/2015 19:51:27 PAGE 4   

 165   2            SystemBuf[Rx]=0x00; //储存出口接收数据   
 166   2          }
 167   1          Rx=0; 
 168   1          sendstring(AT_CMGF); //设置短信的格式为text格式
 169   1          Delay_ms(1000);
 170   1        if((SystemBuf[2]=='O')&&(SystemBuf[3]=='K'))//判断是否模块初始化成功,成功的话模块会回复"OK"给单片机
 171   1          {         //如果单片机没有收到OK,就继续发送初始化指令/   
 172   2            L2=0;
 173   2            for(Rx=0;Rx<RxIn;Rx++)
 174   2            {
 175   3               SystemBuf[Rx]=0x00;   
 176   3            }
 177   2             Rx=0;
 178   2          }
 179   1          else
 180   1          {    
 181   2            L1=0;
 182   2            for(Rx=0;Rx<RxIn;Rx++)
 183   2            {
 184   3                SystemBuf[Rx]=0x00;   
 185   3            }
 186   2            Rx=0; 
 187   2            goto LOOP;           
 188   2          }
 189   1      }
 190          /*********************************************************************************************************
             -*********/
 191          ///////////////////函数void receive_ready(void);实现功能:接收短信准备///////////////////////////////
 192          /*********************************************************************************************************
             -*********/ 
 193          void receive_ready(void)
 194          {
 195   1        uchar i;
 196   1        if((SystemBuf[5]==0x54)&&SystemBuf[6]==0x49)//0x54:T  0x49:I
 197   1          //如果有新短信来,模块会通过串口向单片机发送字符串,
 198   1        {  // 此函数的功能是判断是否有新短信来,如果来的话就置位准备接受位标志为1
 199   2          receiveready=1; //如果不是新短信的指令,就舍弃,并将接收数组清零/
 200   2        }
 201   1        else
 202   1        { 
 203   2          for(i=0;i<Rx;i++)
 204   2          {
 205   3            SystemBuf[i]=0x00;   
 206   3          }
 207   2          Rx=0; 
 208   2        } 
 209   1      }
 210          /*********************************************************************************************************
             -*********/
 211          //函数 void message_read(void);实现功能:判断短信,准备是否回复短信给目标号码//////////////////////////
 212          /*********************************************************************************************************
             -*********/ 
 213           void message_read(void)
 214          { 
 215   1        if((sendready==1)&&(SystemBuf[5]==0x47)&&(SystemBuf[6]==0x52)) //0x47=G,0x52=R
 216   1        send=1;
 217   1      }
 218          /*********************************************************************************************************
             -*********/
 219          ///////////////////函数 void read_message(void);实现功能:发送读取短信指令,////////////////////////////////
             -////////
 220          /*********************************************************************************************************
C51 COMPILER V9.54   GSM3                                                                  11/22/2015 19:51:27 PAGE 5   

             -*********/    
 221          void read_message(void)
 222          {
 223   1        uchar i;
 224   1        Delay_ms(1000);
 225   1        for(i=0;i<3;i++)
 226   1        {
 227   2          numberbuf[i]=SystemBuf[14+i];// numberbuf[3]; 用来保存短信条数
 228   2        }
 229   1        for(i=0;i<8;i++)
 230   1        {
 231   2          AT_Read[i]=AT_CMGR[i];//AT_Read[12];用来存储发送读取短信指令;CMGR：读取短消息 
 232   2        }
 233   1        for(i=8;i<11;i++)
 234   1        {
 235   2          AT_Read[i]=numberbuf[i-8];//AT_Read[12];用来存储发送读取短信指令;
 236   2        }           //numberbuf[3]:用来保存短信条数         
 237   1        for(Rx=0;Rx<RxIn;Rx++)
 238   1        {
 239   2          SystemBuf[Rx]=0x00;    
 240   2        }
 241   1        Rx=0;  
 242   1        sendstring(AT_Read);  //发送AT+CMGR=?,?代表短信储存所在位置
 243   1      }           //AT_Read[12];  //用来存储发送读取短信指令
 244          /*********************************************************************************************************
             -*********/
 245          ////////函数void readcommend(void);实现功能:读取短信内容,判断相应指令是否正确//////////////////////////
 246          /*********************************************************************************************************
             -*********/ 
 247          void readcommend(void)
 248          {
 249   1        uchar i;
 250   1        for(i=0;i<25;i++)  //将短信内容中的指令部分截取出来放到
 251   1        {         //CommandBuf数组中
 252   2          CommandBuf[i]=SystemBuf[78+i];//SystemBuf[RxIn];储存出口接收数据
 253   2        }//CommandBuf[6];用来储存指令 
 254   1        if((CommandBuf[18]=='o')&&(CommandBuf[19]=='p')&&(CommandBuf[20]=='e')&&(CommandBuf[21]=='n')) 
 255   1      //判断指令是否为开继电器指令
 256   1        {
 257   2          switch(CommandBuf[22])
 258   2          {
 259   3            case 0x31: realy0=0;  //继电器 1开启
 260   3            break;
 261   3            case 0x32: realy1=0;  //继电器 2开启
 262   3            break;
 263   3            case 0x33: realy2=0;  //继电器 3开启
 264   3            break;
 265   3            case 0x34: realy3=0;  //继电器 4开启
 266   3            break;
 267   3            case 0x35: realy2=0;  //继电器 5开启
 268   3            break;
 269   3            case 0x36: realy5=0;  //继电器 6开启
 270   3            break;
 271   3            case 0x37: realy6=0;//继电器 7开启
 272   3            break;
 273   3            case 0x38: realy7=0;//继电器 8开启
 274   3            break;
 275   3            case 0x41: key1=0;  //开关1开启
 276   3            break;
 277   3            case 0x42: key2=0;  //开关2开启
 278   3            break;
 279   3            case 0x43: key3=0;  //开关3开启
C51 COMPILER V9.54   GSM3                                                                  11/22/2015 19:51:27 PAGE 6   

 280   3            break;
 281   3            case 0x44: key4=0;  //开关4开启
 282   3            break;
 283   3            case 0x45: key5=0;  //开关5开启
 284   3            break;
 285   3            case 0x46: key6=0;  //开关6开启
 286   3            break;
 287   3            case 0x47: key7=0;  //开关7开启
 288   3            break;
 289   3            case 0x48: key8=0;  //开关8开启
 290   3            break;
 291   3            case 0x4f: P0=0;P2=0;//打开所有的继电器和开关
 292   3            break;
 293   3            case 0x3f: temp1=P0;//记录P0口的状态
 294   3            temp2=P2;//记录P2口的状态
 295   3            temp=temp2;
 296   3            temp<<=8;
 297   3            temp=temp|temp1;//将P0口状态作为低8位,P2口状态作为高8位,组成一个16位的字节放到temp中
 298   3            check=1;
 299   3            break;
 300   3            default:flag=1; //其他指令定义为错误操作                                                            
 301   3            break;    //置位错误操作位为1
 302   3          }
 303   2        }
 304   1        else
 305   1        { 
 306   2          if((CommandBuf[18]=='s')&&(CommandBuf[19]=='h')&&(CommandBuf[20]=='u')&&(CommandBuf[21]=='t'))  
 307   2          {                         //判断指令是否为关闭电器指令
 308   3            
 309   3            switch(CommandBuf[22])
 310   3            {
 311   4              case 0x31: realy0=1;//关闭继电器1
 312   4              break;
 313   4              case 0x32: realy1=1;//关闭继电器2
 314   4              break;
 315   4              case 0x33: realy2=1;//关闭继电器3
 316   4              break;      
 317   4              case 0x34: realy3=1;//关闭继电器4
 318   4              break;
 319   4              case 0x35: realy4=1;//关闭继电器5
 320   4              break;
 321   4              case 0x36: realy5=1;//关闭继电器6
 322   4              break;
 323   4              case 0x37: realy6=1; //关闭继电器7
 324   4              break;
 325   4              case 0x38: realy7=1;//关闭继电器8
 326   4              break;
 327   4              case 0x41: key1=1;  //开关1关闭
 328   4              break;
 329   4              case 0x42: key2=1;  //开关2关闭
 330   4              break;
 331   4              case 0x43: key3=1;  //开关3关闭
 332   4              break;
 333   4              case 0x44: key4=1;  //开关4关闭
 334   4              break;
 335   4              case 0x45: key5=1;  //开关5关闭
 336   4              break;
 337   4              case 0x46: key6=1;  //开关6关闭
 338   4              break;
 339   4              case 0x47: key7=1;  //开关7关闭
 340   4              break;
 341   4              case 0x48: key8=1;  //开关8关闭
C51 COMPILER V9.54   GSM3                                                                  11/22/2015 19:51:27 PAGE 7   

 342   4              break;
 343   4              case 0x53:P0=0xff;P2=0xff;//关闭所有的继电器和开关
 344   4              break;
 345   4              default:flag=1; //其他指令定义为错误操作
 346   4              break;  //置位错误操作位为1
 347   4            }
 348   3          }
 349   2          else {flag=1;}//如果发送的指令既不是open也不是shut就定义为错误操作
 350   2        }
 351   1      }
 352          /*********************************************************************************************************
             -*********/
 353          ///////////////////函数 void readstate;实现功能:将P0,P2口的状态转化为数组,////////////////////////////////
             -////////
 354          /*********************************************************************************************************
             -*********/
 355          void readstate(void)
 356          {  
 357   1        uint bitcnt,i,j;
 358   1        for(bitcnt=0,i=0;bitcnt<16,i<16;bitcnt++,i++)
 359   1        {
 360   2          if((temp<<bitcnt)&0x8000)
 361   2            {
 362   3                state1[i]=0x30;//为什么最高位是1的时候就赋给该位0x30？？？？
 363   3            }
 364   2          else 
 365   2            state1[i]=0x31;//为什么最高位是0的时候就赋给该位0x31？？？？
 366   2        }
 367   1        for(j=15,i=0;j>=0,i<16;j--,i++)
 368   1        {
 369   2          state[j]=state1[i];//state[17];用来存储IO口状态
 370   2        }       //state1[17];用来存储IO口状态
 371   1      }
 372          /*********************************************************************************************************
             -*********/
 373          ///////////////////函数 void delete_message;实现功能:删除读短信指令,//////////////////////////////////////
             -//
 374          /*********************************************************************************************************
             -*********/ 
 375          void delete_message(void)
 376          {
 377   1        uchar i;
 378   1        Delay_ms(1000);
 379   1        Delay_ms(1000);
 380   1        Delay_ms(5000);
 381   1        for(i=0;i<8;i++)
 382   1        {
 383   2          AT_delete[i]=AT_CMGD[i];// AT_CMGD[]="AT+CMGD=";删除保存的短信
 384   2        }
 385   1        for(i=8;i<11;i++)
 386   1        {
 387   2          AT_delete[i]=numberbuf[i-8];  //numberbuf[3];用来保存短信条数         
 388   2        }
 389   1        for(Rx=0;Rx<RxIn;Rx++)
 390   1        {
 391   2          SystemBuf[Rx]=0x00; //SystemBuf[RxIn];储存出口接收数据   
 392   2        }
 393   1        Rx=0;  
 394   1        sendstring(AT_delete);  //发送AT+CMGR=?,?代表短信储存所在位置
 395   1      }
 396          /*********************************************************************************************************
             -*********/
C51 COMPILER V9.54   GSM3                                                                  11/22/2015 19:51:27 PAGE 8   

 397          ///////////////////函数 void sendmessage(void);实现功能:发送回复短信指令,/////////////////////////////////
             -///////
 398          /*********************************************************************************************************
             -*********/  
 399          void sendmessage(void)
 400          {
 401   1        uchar i;
 402   1        for(i=0;i<8;i++)
 403   1        {
 404   2           AT_SendNumber[i]=AT_CMGS[i];// AT_SendNumber[25];用来存储发送短信号码指令
 405   2        }                 //AT_CMGS[]="AT+CMGS=";发送短信指令
 406   1        for(i=8;i<24;i++)
 407   1        {
 408   2           AT_SendNumber[i]=SystemBuf[14+i];//将对方号码提取用来回复给对方
 409   2        }
 410   1        sendstring(AT_SendNumber);
 411   1        Delay_ms(400);
 412   1        if(flag==0)
 413   1        { 
 414   2          if(check==1)
 415   2          {
 416   3            sendstring(state);
 417   3          }//如果查询位置1时,发送状态信息 
 418   2          sendstring(successfully);
 419   2          check=0;
 420   2        }
 421   1        else
 422   1        {
 423   2          sendstring(fail);
 424   2        }
 425   1        Delay_ms(30);
 426   1        sendchar(0X1A);
 427   1      }
 428          /*********************************************************************************************************
             -*********/
 429          ///////////////////函数 void main();实现功能:主函数,////////////////////////////////////////
 430          /*********************************************************************************************************
             -*********/  
 431          void main()
 432          { 
 433   1        Start_GSM();  //开启TC35
 434   1        L1=1;
 435   1        L2=1;
 436   1        Delay_ms(10000);//延时大约10秒 ,等待模块联网/
 437   1        UART_init(); //串口初始化/
 438   1        GSM_INIT(); //对tc35模块进行初始化
 439   1        while(1)
 440   1        {
 441   2          receive_ready();
 442   2          if(receiveready==1)
 443   2          {
 444   3            test4=0;
 445   3            read_message();
 446   3            receiveready=0;
 447   3            sendready=1;
 448   3            Delay_ms(5000);
 449   3            test4=1;
 450   3          }
 451   2           test5=0;
 452   2          Delay_ms(100);
 453   2          test5=1;
 454   2          Delay_ms(300);
C51 COMPILER V9.54   GSM3                                                                  11/22/2015 19:51:27 PAGE 9   

 455   2          message_read();
 456   2          if(send==1)
 457   2          { 
 458   3            Delay_ms(2000);
 459   3            readcommend();
 460   3            readstate(); 
 461   3            sendmessage();
 462   3            Delay_ms(1000);
 463   3            delete_message();
 464   3            flag=0;
 465   3            for(Rx=0;Rx<RxIn;Rx++)  //每一次操作完成后对接收数组清零//
 466   3            {
 467   4              SystemBuf[Rx]=0x00;   
 468   4            }
 469   3            Rx=0;  
 470   3            send=0;
 471   3          } 
 472   2        }
 473   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1152    ----
   CONSTANT SIZE    =    129    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     63    ----
   IDATA SIZE       =    144    ----
   BIT SIZE         =      5    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
